{"ast":null,"code":"//Rest APIs for user authentication and registration\n\nimport jwt_decode from \"jwt-decode\";\nexport const doLogin = (email, password) => {\n  let promiseResolveRef = null;\n  let promiseRejectRef = null;\n  let promise = new Promise((resolve, reject) => {\n    promiseResolveRef = resolve;\n    promiseRejectRef = reject;\n  });\n\n  // Manually specify the token value here\n  const hardcodedToken = \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbkBkZW1vLmNvbSIsImlhdCI6MTczMDEzNDc5MCwiZXhwIjoxNzMwMTQzMTkwfQ.cc3CoVGPvOLPtX0Qx1opGRSgh0G2MwD2vY0USeXNNLFayu0EYhE1nAuua37cb_O8dR-maoNyb1p4HSIN1t5CAw\";\n\n  // Fetch request for login\n  fetch('http://localhost:8080/api/auth/signin', {\n    method: 'POST',\n    body: JSON.stringify({\n      username: email,\n      password: password\n    }),\n    headers: {\n      'Content-type': 'application/json; charset=UTF-8'\n    }\n  }).then(response => {\n    response.json().then(json => {\n      if (response.ok) {\n        // Use the manually specified token instead of fetching from headers\n        const token = hardcodedToken;\n        const decoded = jwt_decode(token);\n        promiseResolveRef({\n          username: json.email,\n          accessToken: token,\n          accessTokenTimeout: decoded.exp * 1000,\n          // Convert expiration to milliseconds\n          roles: json.roles,\n          userId: json.id,\n          response: response\n        });\n      } else {\n        promiseRejectRef({\n          reason: \"Server error occurred. Please try again.\",\n          response: response\n        });\n      }\n    }).catch(error => {\n      promiseRejectRef({\n        reason: \"Bad Credentials. Please try again.\",\n        response: error\n      });\n    });\n  }).catch(err => {\n    promiseRejectRef({\n      reason: \"Some error occurred. Please try again.\",\n      response: err\n    });\n  });\n  return promise;\n};\nexport const doSignup = requestJson => {\n  //Note: we are returning promise so that we can resolve it by using appropriate data type like json or text\n  //caller of the function should only be concerned with returned data on success or failure message\n  let promiseResolveRef = null;\n  let promiseRejectRef = null;\n  let promise = new Promise((resolve, reject) => {\n    promiseResolveRef = resolve;\n    promiseRejectRef = reject;\n  });\n  fetch('http://localhost:8080/api/auth/signup', {\n    method: 'POST',\n    body: JSON.stringify(requestJson),\n    headers: {\n      'Content-type': 'application/json; charset=UTF-8'\n    }\n  }).then(response => {\n    response.json().then(json => {\n      if (response.ok) {\n        promiseResolveRef({\n          message: json.message,\n          response: response\n        });\n      } else {\n        let message = json.message;\n        if (message === undefined || message === null) {\n          message = \"Server error occurred. Please try again.\";\n        }\n        promiseRejectRef({\n          reason: message,\n          response: response\n        });\n      }\n    }).catch(err => {\n      promiseRejectRef({\n        reason: \"Some error occurred. Please try again.\",\n        response: err\n      });\n    });\n  }).catch(err => {\n    promiseRejectRef({\n      reason: \"Some error occurred. Please try again.\",\n      response: err\n    });\n  });\n  return promise;\n};","map":{"version":3,"names":["jwt_decode","doLogin","email","password","promiseResolveRef","promiseRejectRef","promise","Promise","resolve","reject","hardcodedToken","fetch","method","body","JSON","stringify","username","headers","then","response","json","ok","token","decoded","accessToken","accessTokenTimeout","exp","roles","userId","id","reason","catch","error","err","doSignup","requestJson","message","undefined"],"sources":["D:/Upgrad/Upgrad_Git_Sample/upGrad-Eshop-Application-main/src/api/userAuthAPIs.js"],"sourcesContent":["//Rest APIs for user authentication and registration\n\nimport jwt_decode from \"jwt-decode\";\n\nexport const doLogin = (email, password) => {\n\tlet promiseResolveRef = null;\n\tlet promiseRejectRef = null;\n\tlet promise = new Promise((resolve, reject) => {\n\t\tpromiseResolveRef = resolve;\n\t\tpromiseRejectRef = reject;\n\t});\n\t\n\t// Manually specify the token value here\n\tconst hardcodedToken = \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbkBkZW1vLmNvbSIsImlhdCI6MTczMDEzNDc5MCwiZXhwIjoxNzMwMTQzMTkwfQ.cc3CoVGPvOLPtX0Qx1opGRSgh0G2MwD2vY0USeXNNLFayu0EYhE1nAuua37cb_O8dR-maoNyb1p4HSIN1t5CAw\";\n\n\t// Fetch request for login\n\tfetch('http://localhost:8080/api/auth/signin', {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({\n\t\t\tusername: email,\n\t\t\tpassword: password,\n\t\t}),\n\t\theaders: {\n\t\t\t'Content-type': 'application/json; charset=UTF-8',\n\t\t},\n\t})\n\t.then((response) => {\n\t\tresponse.json().then((json) => {\n\t\t\tif (response.ok) {\n\t\t\t\t// Use the manually specified token instead of fetching from headers\n\t\t\t\tconst token = hardcodedToken;\n\t\t\t\tconst decoded = jwt_decode(token);\n\n\t\t\t\tpromiseResolveRef({\n\t\t\t\t\tusername: json.email,\n\t\t\t\t\taccessToken: token,\n\t\t\t\t\taccessTokenTimeout: decoded.exp * 1000, // Convert expiration to milliseconds\n\t\t\t\t\troles: json.roles,\n\t\t\t\t\tuserId: json.id,\n\t\t\t\t\tresponse: response,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tpromiseRejectRef({\n\t\t\t\t\treason: \"Server error occurred. Please try again.\",\n\t\t\t\t\tresponse: response,\n\t\t\t\t});\n\t\t\t}\n\t\t}).catch((error) => {\n\t\t\tpromiseRejectRef({\n\t\t\t\treason: \"Bad Credentials. Please try again.\",\n\t\t\t\tresponse: error,\n\t\t\t});\n\t\t});\n\t}).catch((err) => {\n\t\tpromiseRejectRef({\n\t\t\treason: \"Some error occurred. Please try again.\",\n\t\t\tresponse: err,\n\t\t});\n\t});\n\treturn promise;\n};\n\nexport const doSignup = (requestJson) => {\n\t//Note: we are returning promise so that we can resolve it by using appropriate data type like json or text\n\t//caller of the function should only be concerned with returned data on success or failure message\n\tlet promiseResolveRef = null;\n\tlet promiseRejectRef = null;\n\tlet promise = new Promise((resolve, reject) => {\n\t\tpromiseResolveRef = resolve;\n\t\tpromiseRejectRef = reject;\n\t});\n\tfetch('http://localhost:8080/api/auth/signup', {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify(requestJson),\n\t\theaders: {\n\t\t\t'Content-type': 'application/json; charset=UTF-8',\n\t\t},\n\t}).then((response) => {\n\t\tresponse.json().then((json) => {\n\t\t\tif(response.ok) {\n\t\t\t\tpromiseResolveRef({\n\t\t\t\t\tmessage: json.message,\n\t\t\t\t\tresponse: response,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet message = json.message;\n\t\t\t\tif(message === undefined || message === null) {\n\t\t\t\t\tmessage = \"Server error occurred. Please try again.\";\n\t\t\t\t}\n\t\t\t\tpromiseRejectRef({\n\t\t\t\t\treason: message,\n\t\t\t\t\tresponse: response,\n\t\t\t\t});\n\t\t\t}\n\t\t}).catch((err) => {\n\t\t\tpromiseRejectRef({\n\t\t\t\treason: \"Some error occurred. Please try again.\",\n\t\t\t\tresponse: err,\n\t\t\t});\n\t\t});\n\t}).catch((err) => {\n\t\tpromiseRejectRef({\n\t\t\treason: \"Some error occurred. Please try again.\",\n\t\t\tresponse: err,\n\t\t});\n\t});\n\treturn promise;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}